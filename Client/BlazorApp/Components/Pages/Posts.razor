@page "/posts"
@using ApiContracts.Posts
@using ApiContracts.Users
@inject BlazorApp.Services.Interfaces.IPostService postService
@inject BlazorApp.Services.Interfaces.IUserService userService
@inject AuthenticationStateProvider AuthProvider

<h4 class="mb-3">Posts</h4>

<!-- CREATE / EDIT FORM (one form for both) -->
<div class="card mb-4">
  <div class="card-body">
    <h5 class="mb-3">@(isEditing ? "Edit Post" : "Create a Post")</h5>

    @* show login info *@
    @if (!isLoggedIn)
    {
      <div class="alert alert-info mb-3">
        Please log in to create or edit your posts.
      </div>
    }

    <div class="row g-3">
      <div class="col-12">
        <label class="form-label">Title</label>
        <input class="form-control" @bind="title" />
      </div>

      <div class="col-12">
        <label class="form-label">Body</label>
        <textarea class="form-control" rows="5" @bind="body"></textarea>
      </div>

      <div class="col-12 col-md-4">
        <label class="form-label">Author User Id</label>
        <input type="number" class="form-control" @bind="authorId" disabled /> @* always from auth *@
      </div>

      <div class="col-12">
        @if (!isEditing)
        {
          <button class="btn btn-success" @onclick="Create" disabled="@(!isLoggedIn || busy)">
            @if (busy) { <span class="spinner-border spinner-border-sm me-1"></span> } Publish
          </button>
        }
        else
        {
          <button class="btn btn-primary me-2" @onclick="Update" disabled="@busy || !isEditingMyOwn || !isLoggedIn">
            @if (busy) { <span class="spinner-border spinner-border-sm me-1"></span> } Save changes
          </button>
          <button class="btn btn-secondary" @onclick="CancelEdit">Cancel</button>
        }

        @if (!string.IsNullOrWhiteSpace(error)) { <span class="text-danger ms-2">@error</span> }
        @if (!string.IsNullOrWhiteSpace(ok))    { <span class="text-success ms-2">@ok</span> }
      </div>
    </div>
  </div>
</div>

<!-- FILTER + LIST -->
<div class="d-flex gap-2 mb-3">
  <input class="form-control" placeholder="Title contains..." @bind="titleFilter" @bind:event="oninput" />
  <button class="btn btn-outline-secondary" @onclick="Load">Search</button>
</div>

@if (loading)
{
  <Loading />
}
else if (items is null || items.Count == 0)
{
  <div class="alert alert-light border">No posts found.</div>
}
else
{
  @foreach (var p in items)
  {
    var owner = ownedPostIds.Contains(p.Id);  @* <- ownership without touching PostSummaryDto *@
    <div class="card mb-2">
      <div class="card-body">
        <a class="h5 text-decoration-none" href="/posts/@p.Id">@p.Title</a>
        <div class="text-muted small">
          by @(string.IsNullOrWhiteSpace(p.AuthorName) ? "Unknown" : p.AuthorName)
        </div>
      </div>
      <div class="card-footer d-flex gap-2">
        <a class="btn btn-sm btn-outline-secondary" href="/posts/@p.Id">View</a>
        @if (owner && isLoggedIn)
        {
          <button class="btn btn-sm btn-outline-primary" @onclick="() => StartEdit(p.Id)">Edit</button>
          <button class="btn btn-sm btn-outline-danger"  @onclick="() => Delete(p.Id)">Delete</button>
        }
        else
        {
          <span class="text-muted small">— read-only —</span>
        }
      </div>
    </div>
  }
}

@code {
  // list + filter
  private string? titleFilter;
  private List<PostSummaryDto>? items;
  private bool loading;

  // create/edit form state
  private string? title, body, error, ok;
  private int authorId;            // filled from auth
  private bool busy, isEditing = false;
  private int editingPostId;
  private bool isEditingMyOwn;

  // auth/ownership
  private int currentUserId;
  private bool isLoggedIn;                  // login flag
  private HashSet<int> ownedPostIds = new();   // <- ADDED

  protected override async Task OnInitializedAsync()
  {
    // read auth user
    var auth = await AuthProvider.GetAuthenticationStateAsync();
    currentUserId = int.TryParse(auth.User.FindFirst("Id")?.Value, out var id) ? id : 0;
    isLoggedIn = currentUserId > 0;        // logged-in flag
    authorId = currentUserId;              // author for create
    await Load();
  }

  // Load summaries + compute ownership without modifying PostSummaryDto
  private async Task Load()
  {
    loading = true; error = ok = null;
    try
    {
      // always load all
      var summaries = await postService.GetPostsAsync(
        new PostQueryParameters { TitleContains = null }); // server-all

      var users = await userService.GetAllUsersAsync();
      var usersById = users.ToDictionary(u => u.Id, u => u.UserName);

      ownedPostIds.Clear();

      var filtered = new List<PostSummaryDto>(); // local list

      foreach (var s in summaries)
      {
        var full = await postService.GetPostByIdAsync(s.Id); // load full

        if (usersById.TryGetValue(full.AuthorUserId, out var name))
          s.AuthorName = name;

        if (full.AuthorUserId == currentUserId)
          ownedPostIds.Add(s.Id);

        // text / id filter
        if (!string.IsNullOrWhiteSpace(titleFilter))
        {
          var term = titleFilter.Trim();
          var matchesId = int.TryParse(term, out var idFilter) && s.Id == idFilter;
          var matchesTitle = !string.IsNullOrEmpty(s.Title)
                             && s.Title.Contains(term, StringComparison.OrdinalIgnoreCase);
          var matchesBody = !string.IsNullOrEmpty(full.Body)
                            && full.Body.Contains(term, StringComparison.OrdinalIgnoreCase);

          if (!(matchesId || matchesTitle || matchesBody))
            continue;
        }

        // only my posts
        if (isLoggedIn && full.AuthorUserId != currentUserId)
          continue;

        filtered.Add(s);
      }

      items = filtered; // final list
    }
    finally { loading = false; }
  }

  private async Task Create() // create new post
  {
    error = ok = null;

    if (!isLoggedIn)
    {
      error = "Please log in to create posts.";
      return;
    }

    if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(body))
    {
      error = "Title and Body are required.";
      return;
    }

    busy = true;
    try
    {
      await postService.CreatePostAsync(new CreatePostDto
      {
        Title = title!, Body = body!, AuthorUserId = currentUserId
      });

      title = body = string.Empty;
      ok = "Post published.";
      await Load();
    }
    catch (Exception ex) { error = ex.Message; }
    finally { busy = false; }
  }

  private async Task StartEdit(int id) // start editing
  {
    error = ok = null;

    if (!isLoggedIn)
    {
      error = "Please log in to edit posts.";
      return;
    }

    var full = await postService.GetPostByIdAsync(id);
    editingPostId = id;
    title = full.Title;
    body  = full.Body;
    isEditingMyOwn = (full.AuthorUserId == currentUserId);
    isEditing = true;
  }

  private async Task Update() // update existing
  {
    if (!isEditingMyOwn || !isLoggedIn) return;

    error = ok = null;
    if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(body))
    {
      error = "Title and Body are required.";
      return;
    }

    busy = true;
    try
    {
      await postService.UpdatePostAsync(editingPostId, new UpdatePostDto
      {
        Title = title!, Body = body!
      });

      ok = "Post updated.";
      isEditing = false;
      title = body = string.Empty;
      await Load();
    }
    catch (Exception ex) { error = ex.Message; }
    finally { busy = false; }
  }

  private void CancelEdit() // reset form
  {
    isEditing = false;
    title = body = string.Empty;
    ok = error = null;
  }

  private async Task Delete(int id) // delete post
  {
    error = ok = null;

    if (!isLoggedIn)
    {
      error = "Please log in to delete posts.";
      return;
    }

    var full = await postService.GetPostByIdAsync(id);
    if (full.AuthorUserId != currentUserId) return;

    try
    {
      await postService.DeletePostAsync(id);
      items!.RemoveAll(x => x.Id == id);
      ownedPostIds.Remove(id);
      ok = "Post deleted.";
      StateHasChanged();
    }
    catch (Exception ex) { error = ex.Message; }
  }
}
